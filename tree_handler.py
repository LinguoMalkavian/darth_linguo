# This is a library of utilities to deal with the parse trees generated by the
# stanford core nlp for spanish

import re

# a regular expresion that matches the shape of terminal nodes
terminalshape = re.compile("\(([a-z0]{1,8}) ([A-Za-záéíóúñÑÁÉÍÓÚ]+)\)")
labelshape = re.compile("\(([a-z0-9.]+|ROOT)")


# Generator function to process input text
def sentence_str_generator(in_file):
    nextline = in_file.readline()
    while nextline:
        curr_block = ""
        while nextline.strip() != "":
            curr_block += nextline
            nextline = in_file.readline()
        yield curr_block
        nextline = in_file.readline()


# Generator function for sentence objects from a file
def sentence_obj_generator(in_file):
    for sentence_str in sentence_str_generator(in_file):
        sentence_obj = Sentence_obj(sentence_str)
        yield sentence_obj


def loadTree(treeString):
    "Takes string representation of a tree and returns it as a syntactic tree"

    # base case, string is the representation of a terminal
    terminalMatch = terminalshape.match(treeString.strip())
    if terminalMatch:
        newNode = Node(terminalMatch.group(1), isTerminal=True,
                       text=terminalMatch.group(2))
        return newNode
    else:
        # non terminal case, extract kind, do recursive calls on the daughters
        # then build the node
        daughters = []
        treeString = treeString.strip()[:-1]
        kind = labelshape.search(treeString.strip()).group(1)
        treeString = labelshape.sub("", treeString, count=1)
        parencount = 0
        lastind = 0
        for ind in range(len(treeString)):
            char = treeString[ind]
            if char == "(":
                parencount += 1
            elif char == ")":
                parencount = parencount - 1
                if parencount == 0:
                    daughters.append(loadTree(treeString[lastind:ind+1]))
                    lastind = ind+1
        newNode = Node(kind, daughters)
        newNode.consolidateText()
        return newNode


class Node:

    def __init__(self, kind, daughters=[], isTerminal=False, text=""):
        self.daughters = daughters
        self.kind = kind
        self.isTerminal = isTerminal

        if(isTerminal):
            self.text = text
        else:
            self.text = self.consolidateText()

        self.consolidateMotherhood()
        if kind == "ROOT":
            self.mother = None

    def addDaughter(self, newDaughter):
        self.daughters.append(newDaughter)

    def consolidateText(self):
        if not self.isTerminal:
            return " ".join([d.text for d in self.daughters])
        else:
            return self.text

    def consolidateMotherhood(self):
        for daughter in self.daughters:
            daughter.mother = self

    def getKind(self):
        return self.kind

    def getDaughters(self):
        return self.daughters

    def getMother(self):
        return self.mother

    def getText(self):
        return self.text


class Sentence_obj:

    # Regexes to be used
    lead_regex = re.compile("Sentence #(\d+) \((\d+) tokens\):")
    item_regex = re.compile(
    "\[Text=([A-Za-záéíóúñÑÁÉÍÓÚ0-9]+|[\",.;:]) CharacterOffsetBegin=\d+ CharacterOffsetEnd=\d+ PartOfSpeech=([a-z0]{1,8}) NamedEntityTag=\w+\]")

    # Takes a structured string and stores the necesary stuff
    def __init__(self, sentence_str):
        lines = sentence_str.splitlines()
        # First line is Sentence#x
        firstmatch = Sentence_obj.lead_regex.match(lines.pop(0))
        self.sent_num = firstmatch.group(1)
        # One or more lines of plain text
        line = lines.pop(0)
        self.text = ""
        while Sentence_obj.item_regex.match(line) is None:
            self.text += line + "\n"
            line = lines.pop(0)

        # One or more lines defining items in the format:
        self.tokens = []
        this_match = Sentence_obj.item_regex.match(line)
        while this_match is not None:
            token_text = this_match.group(1)
            token_beg = this_match.group(2)
            token_end = this_match.group(3)
            token_pos = this_match.group(4)
            token_NET = this_match.group(5)
            new_token = Token(
                             token_text,
                             token_beg,
                             token_end,
                             token_pos,
                             token_NET,
            )
            self.tokens.append(new_token)
            line = lines.pop(0)
            this_match = Sentence_obj.item_regex.match(line)
        # [Text=Str1 CharacterOffsetBegin=x CharacterOffsetEnd=y
        # PartfSpeech=POS NamedEntityTag=NET]
        remaining = "\n".join(lines)
        self.tree = loadTree(remaining.strip())

        # Tree representation, starts with the fist line to not match  regex
        # Hand to loadTree


class Token:

    def __init__(self, text, beg, end, pos, NET):
        self.text = text
        self.beg = beg
        self.end = end
        self.pos = pos
        self.NET = NET
